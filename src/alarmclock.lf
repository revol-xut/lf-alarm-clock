target Cpp {
    keepalive: true
}

public preamble {=
    #include <functional>
    #include <memory>
    #include <string>
    #include <iostream>

    struct Event {
        std::string message_;
        unsigned int time_stamp_;
    };
=}

reactor Trigger {
    input event: std::string;
    reaction(event) {=
        if(event.is_present()){
            std::cout << "Triggering Event: " << *(event.get().get()) << std::endl;
        }
    =}
}

reactor Filter {
    trigger = new Trigger();

    input events: std::vector<Event>;
    output updated: std::vector<std::size_t>;
    output event: Event;

    reaction (events) -> trigger.event, updated {=
        // lambda which checks if a given event needs to execute
        // and than triggers the event
        auto lambda_trigger = [=](const Event& event){
            auto unix_time = (event.time_stamp_);

            if( std::chrono::steady_clock::now().time_since_epoch().count() > unix_time ){
                trigger.event.set(event.message_);
                return true;
            }
            return false;
        };

        // list of element which can be removed in the next iteration
        std::vector<std::size_t> removed_indices;
        if ( events.is_present() ){
            std::size_t index = 0;
            for(const Event& event: *events.get().get()) {
                if (lambda_trigger(event)){
                    removed_indices.push_back(index);
                }
                index++;
            }
        }

        // pushes updated element set out
        updated.set(removed_indices);
    =}
}

reactor Clock {
    input file: std::string;
    input event: Event;
    input removed: std::vector<std::size_t>;

    timer t(0, 1 sec);
    state events: std::vector<Event>();
    output events_out: std::vector<Event>;

    // reaction that appends elements
    reaction (event) {=
        if (event.is_present() ){
            events.push_back(*event.get().get());
        }
    =}

    // reaction that triggers file read
    reaction (file) {=
        std::cout << "Read Event from file" << std::endl;
    =}

    // checking periodically if elements need to be triggered
    reaction (t) -> events_out {=
        events_out.set(events);
    =}

    reaction (removed) {=
        std::size_t removed_counter = 0;
        for (std::size_t i : *(removed.get().get())) {
            std::cout << "Removed" << std::endl;
            events.erase(events.begin() + i - removed_counter);
            removed_counter++;
        }
    =}
}

main reactor alarmclock {
    clock = new Clock();
    filter = new Filter();

    clock.events_out -> filter.events;
    filter.updated -> clock.removed;

    reaction(startup) -> clock.event {=
        std::cout << "Starting Alarm Clock Reactor !" << std::endl;
        Event e{
            std::string("Test"),
            9000
        };
        clock.event.set(e);
    =}
}

