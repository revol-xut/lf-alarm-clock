

target Cpp{
    cmake-include: "Alarmclock.cmake",
    keepalive: true
};


public preamble {=
    #include <boost/asio.hpp>
    #include <iostream>
    #include <string>
    #include <thread>
    #include <fstream>
    #include <filesystem>

    struct Event {
        std::string message_;
        unsigned int time_stamp_;
    };
    
    struct ParsedHeader {
        std::string method_;
        std::string endpoint_;
        std::string body_;
    };

    constexpr short kBackLog = 30;
    constexpr unsigned short kPort = 6666;
    constexpr const char* kMusicDir = "/home/revol-xut/music/AlarmClock/";
    constexpr const char* kFile = "./alarm_clock_events.csv";
=}


reactor Trigger {
    input event: std::string;
    input stop: void;

    reaction(event) {=
        auto select_random_file = []{
            std::vector<std::string> files;
            for (const auto& file : std::filesystem::directory_iterator(kMusicDir)) {
                files.push_back(file.path().filename());
            }

            return files[rand() % files.size()];
        };

        if(event.is_present()){
            std::cout << "Triggering Event: " << *(event.get().get()) << std::endl;
            std::string command = "mpc add AlarmClock/" + select_random_file();
            std::cout << command << std::endl;
            system(command.c_str());
        }
    =}
}

reactor Filter {
    trigger = new Trigger();

    input events: std::vector<Event>;
    output updated: std::vector<std::size_t>;
    output event: Event;

    reaction (events) -> trigger.event, updated {=
        // lambda which checks if a given event needs to execute
        // and than triggers the event
        auto lambda_trigger = [=](const Event& event){
            auto unix_time = (event.time_stamp_);
            const auto p1 = std::chrono::system_clock::now();
            auto current_time = std::chrono::duration_cast<std::chrono::seconds>(p1.time_since_epoch()).count();

            // checks if the element is between now and 30s ago
            if(current_time - 30 < unix_time and current_time > unix_time  ){
                trigger.event.set(event.message_);
                return true;
            } else if ( current_time > unix_time ) {
                return true;
            }
            return false;
        };

        // list of element which can be removed in the next iteration
        std::vector<std::size_t> removed_indices;
        if ( events.is_present() ){
            std::size_t index = 0;
            for(const Event& event: *events.get().get()) {
                if (lambda_trigger(event)){
                    removed_indices.push_back(index);
                }
                index++;
            }
        }

        // pushes updated element set out
        updated.set(removed_indices);
    =}
}

reactor Clock {
    input event: Event;
    input removed: std::vector<std::size_t>;

    timer t(0, 1 sec);
    timer saver(10 sec, 30 sec);
    state events: std::vector<Event>();
    output events_out: std::vector<Event>;

    // reaction that appends elements
    reaction (event) {=
        if (event.is_present() ){
            std::cout << "Adding Element" << std::endl;
            events.push_back(*event.get().get());
        }
    =}

    // checking periodically if elements need to be triggered
    reaction (t) -> events_out {=
        events_out.set(events);
    =}

    // list of events which got triggered last time and therefore an be removed now
    reaction (removed) {=
        std::size_t removed_counter = 0;
        for (std::size_t i : *(removed.get().get())) {
            events.erase(events.begin() + i - removed_counter);
            removed_counter++;
        }
    =}

    // initiation ... reading file to create state 
    reaction (startup) {=
        std::ifstream file;
        file.open(kFile);

        std::string line;
        if(not file.is_open()) {
            throw std::runtime_error("Cannot open event file!");
        }

        while (file) {
            std::getline(file, line);
            if (line.empty()) {
                break;
            }

            Event serialized_event {};
            std::size_t colon_pos = line.find(";");
            serialized_event.message_ = line.substr(0, colon_pos);
            serialized_event.time_stamp_ = static_cast<unsigned int>(
                std::stoi(line.substr(colon_pos + 1, line.size() - 2))
            );

            events.push_back(serialized_event);
        }

        file.close();
    =}

    // state needs to be saved to file
    reaction (shutdown, saver) {=
        std::ofstream file(kFile, std::ios::trunc);

        for (const Event& e : events ) {
            file << e.message_ + ";" + std::to_string(e.time_stamp_) + "\n";
        }

        file.close();
    =}
}


main reactor Connection{
    clock = new Clock();
    filter = new Filter();
    clock.events_out -> filter.events;
    filter.updated -> clock.removed;

    physical action new_event: {= Event =};
    state running: bool(true);
    state thread: {= std::thread =}

    input terminate: void;
    output event: {= std::string =};

    method responde(raw_data: {= std::array<char, 4096>& =}): {= ParsedHeader =} {=
        const std::string kContentLenght = "Content-Length";
        std::string data(raw_data.data(), 4096);
        std::string header, str_iterator, body;
        std::size_t current_position = 0;
        std::size_t content_length = 0;

        // start parsing the http header
        auto index_method = data.find(" ");
        std::string http_method = data.substr(0, index_method);
        auto index_endpoint = data.find(" ");
        std::string http_endpoint = data.substr(index_method + 1, index_method + index_endpoint - 4);

        // this jumps to the beginning of the body line by line
        std::istringstream iss(data);

        for (std::string line; std::getline(iss, line); ){
            current_position += line.size();
            if(line.empty()) {
                break;
            }else if( line.substr(0, kContentLenght.size()) == kContentLenght ){
                auto pos = line.find(" ");
                content_length = std::stoi(line.substr(pos + 1, line.size()));
                current_position += 8;
                break;
            }
        }

        // concatenates the body together
        body = data.substr(current_position, current_position + content_length);
        return ParsedHeader {
            http_method,
            http_endpoint,
            body
        };
    =}

    reaction (new_event) -> clock.event {=
        clock.event.set(new_event.get());
    =}


    reaction (startup) -> new_event {=
        std::cout << "Starting Alarm Clock Reactor !" << std::endl;

        thread = std::thread([&]{
            // initializing network objects from beast boost
            boost::asio::ip::tcp::endpoint ep(boost::asio::ip::address_v4::any(), kPort);
            boost::asio::io_service ios;
            boost::asio::ip::tcp::acceptor acceptor(ios, ep.protocol());
            acceptor.bind(ep);
            acceptor.listen(kBackLog);
            boost::asio::ip::tcp::socket sock(ios);

            std::array<char, 4096> data;
            Event serialized_event {};

            std::cout << "Started Receiving" << std::endl;

            while (running){
                acceptor.accept(sock); 
                sock.read_some(boost::asio::buffer(data));
                auto header = responde(data);
                std::string response;

                // handleing the endpoints
                if (header.method_ == "POST" and header.endpoint_ == "/list") {
                    response = "LISTING";
                } else if( header.method_ == "POST" and header.endpoint_ == "/stop") {
                    response = "STOP";
                    system("mpc next");
                } else if( header.method_ == "POST" and header.endpoint_ == "/add") {
                    response = "ADDING";

                    std::size_t colon_pos = header.body_.find(";");
                    serialized_event.message_ = header.body_.substr(0, colon_pos);
                    serialized_event.time_stamp_ = static_cast<unsigned int>(
                        std::stoi(header.body_.substr(colon_pos + 1, header.body_.size() - 2)));

                    new_event.schedule(serialized_event, 0ms);
                }else {
                    response = "NO VALID ENDPOINT";
                }

                sock.write_some(boost::asio::buffer(response));
                sock.close();
            }
        });
    =}

    reaction ( shutdown ) {=
        thread.join();
    =}

    reaction (terminate) {=
        running = false;
    =}

}
