

target Cpp{
    cmake-include: "AlarmClock.cmake",
    keepalive: true
};


public preamble {=
    #include <boost/asio.hpp>
    #include <iostream>
    #include <string>
    #include <thread>
    #include <fstream>
    #include <filesystem>

    struct Event {
        std::string message_;
        unsigned int time_stamp_;
    };
    
    struct ParsedHeader {
        std::string method_;
        std::string endpoint_;
        std::string body_;
    };
    
    constexpr short kBackLog = 30;
    constexpr unsigned short kPort = 6666;
    constexpr const char* kMusicDir = "/home/revol-xut/music/AlarmClock/";
    constexpr const char* kFile = "./alarm_clock_events.csv";
=}


reactor Trigger {
    input stop: void;
    input input_event: {=Event=};
    logical action triggered_event: {=std::string=};
    
    reaction (input_event) -> triggered_event {=
        if(input_event.is_present()) {
            auto extracted = input_event.get().get();
            const auto t = std::chrono::system_clock::now();
            std::chrono::seconds desired_time = std::chrono::seconds(extracted->time_stamp_);
            std::chrono::seconds current_time = std::chrono::duration_cast<std::chrono::seconds>(t.time_since_epoch());
            std::chrono::seconds delta_t = desired_time - current_time;
            triggered_event.schedule(extracted->message_, delta_t);
        }
    =}

    reaction(triggered_event) {=
        auto select_random_file = []{
            std::vector<std::string> files;
            for (const auto& file : std::filesystem::directory_iterator(kMusicDir)) {
                files.push_back(file.path().filename());
            }

            return files[rand() % files.size()];
        };

        if(triggered_event.is_present()){
            std::cout << "Triggering Event: " << *(triggered_event.get().get()) << std::endl;
            std::string command = "mpc add AlarmClock/" + select_random_file();
            if( system(command.c_str()) != 0 ){
                std::runtime_error("mpc finished with non zero return value");
            }
        }
    =}
}

reactor Clock {
    private preamble {=
        auto time_over(const Event& event) noexcept -> bool {
            auto unix_time = (event.time_stamp_);
            const auto p1 = std::chrono::system_clock::now();
            auto current_time = std::chrono::duration_cast<std::chrono::seconds>(p1.time_since_epoch()).count();
            return current_time > unix_time;
        }
    =}
    trigger = new Trigger();
    // this event will be scheduled and added to persistent storage
    input event: Event;
    // list of indices which can be removed from persistent storage
    input removed: std::vector<std::size_t>;
    // timer which triggers clear and save
    timer maintance(10 sec, 30 sec);

    // persistant storage
    state events: std::vector<Event>();
    output events_out: std::vector<Event>;

    // reaction that appends elements
    reaction (event) -> trigger.input_event {=
        if (event.is_present() ){
            auto extracted = event.get().get();
            std::cout << "Adding event to event pipeline\n" << std::endl;
            trigger.input_event.set(*extracted);
        }
    =}

    // checking periodically if elements need to be triggered
    reaction (maintance) -> events_out {=
        events_out.set(events);
    =}

    // initiation ... reading file to create state 
    reaction (startup) -> trigger.input_event {=
        if (not std::filesystem::exists(kFile)){
            std::ofstream{kFile};
        }

        std::ifstream file;
        file.open(kFile);

        std::string line;
        if(not file.is_open()) {
            throw std::runtime_error("Cannot open event file!");
        }

        while (file) {
            std::getline(file, line);
            if (line.empty()) {
                break;
            }

            Event serialized_event {};
            std::size_t colon_pos = line.find(";");
            serialized_event.message_ = line.substr(0, colon_pos);
            serialized_event.time_stamp_ = static_cast<unsigned int>(
                std::stoi(line.substr(colon_pos + 1, line.size() - 2))
            );

            if(not time_over(serialized_event)){
                trigger.input_event.set(serialized_event);
                events.push_back(serialized_event);
            }
        }

        file.close();
    =}

    // state needs to be saved to file
    reaction (shutdown, maintance) {=
        remove_events();
        save();
    =}

    method remove_events() {=
        // list of element which can be removed in the next iteration
        std::vector<std::size_t> removed_indices;
        std::size_t index = 0;
        for(const Event& event: events) {
            if (time_over(event)){
                removed_indices.push_back(index);
            }
            index++;
        }

        std::size_t removed_counter = 0;
        for (std::size_t i : removed_indices) {
            events.erase(events.begin() + i - removed_counter);
            removed_counter++;
        }
    =}
    
    method save() {=
        std::ofstream file(kFile, std::ios::trunc);

        for (const Event& e : events ) {
            file << e.message_ + ";" + std::to_string(e.time_stamp_) + "\n";
        }

        file.close();
    =}

    const method print_events(): {=std::string=} {=
        std::string return_value;

        auto unix_to_human_readable = [](unsigned int time_stamp){
            using Clock = std::chrono::high_resolution_clock;
            using TimePoint = std::chrono::time_point<Clock>;
            
            const Clock::duration duration_time_stamp = std::chrono::seconds(time_stamp);
            const TimePoint chrono_time_point(duration_time_stamp);
            std::time_t end_time = std::chrono::system_clock::to_time_t(chrono_time_point);
            return std::ctime(&end_time);
        };

        for (const Event& event: events) {
            return_value += event.message_ + ";" + unix_to_human_readable(event.time_stamp_) + "\n";
        };

        return return_value;
    =}
}

