/*
* This is a minimal example of an alarmclock implemeted using the 
* features lingua franca supplies.
* 
* This is just an extract and simplification from the main project
* which you can find here: https://github.com/revol-xut/lf-alarm-clock
* 
* This file contains the networking implementation it is really just an
* simple socket application which parses simple http headers and respondes
* in text/plain
*
* @author Tassilo Tanneberer <tassilo.tanneberger@tu-dresden.de>
*/

target Cpp{
    cmake-include: "AlarmClock.cmake",
    keepalive: true
};

public preamble {=
    #include "../../../src/shared_header.hpp"
    #include "../../../src/crow_all.h"
=}


reactor Network {
    // physical event which is triggered by receiving a request
    physical action new_event: {= Event =};

    // variables for the receive thread
    state running: bool(true);
    state thread: {= std::thread =}; // receive thread
    state events: {= std::vector =}; // copy

    input terminate: void;
    input updated_events: {= std::vector =};

    output event: {= Event =}; // event which will be added to the clock

    // this reaction transforms a physical action into a logical reaction
    reaction (new_event) -> event {=
        event.set(new_event.get());
    =}

    // main starts receive thread
    reaction (startup) -> new_event {=
        std::cout << "Starting Alarmclock Reactor!\n" << std::endl;
        constexpr const char* kResponseHeader = "HTTP/1.0 200 OK\nContent-Type: text/plain\n\n";

        thread = std::thread([&]{
            crow::SimpleApp app;
            CROW_ROUTE(app, "/list") ([events]{
                    crow::json::wvalue x;
                    x["events"] = std::vector<crow::json::wvalue>();
                    std::size_t index = 0;
                    for (const Event& event : events ){
                        crow::json::wvalue json_event;
                        json_event["date"] = 
                        json_event["message"] = event.message_;
                        x["events"].push_back(json_event);
                    };

                    return x;
            });

            CROW_ROUTE(app, "/add_event").methods("POST"_method)
            ([&new_event](const crow::request& req){
                auto json_body = crow::json::load(req.body);
                if (!json_body) {
                    return crow::response(400);
                }

                Event serialized_event {
                    json_body["message"].s(),
                    static_cast<unsigned int>(json_body["time_stamp"].u())
                };
                new_event.schedule(serialized_event, 0ms);
                
                crow::json::wvalue response;
                response["success"] = true;
                return crow::response(response);
            });
            app.port(8680).run();

        });
    =}
    reaction (updated_events) {=
        events  = std::move(*updated_events.get());
    =}


    reaction ( shutdown ) {=
        thread.join();
    =}

    reaction (terminate) {=
        running = false;
    =}

}
