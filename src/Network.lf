/*
* This is a minimal example of an alarmclock implemeted using the 
* features lingua franca supplies.
* 
* This is just an extract and simplification from the main project
* which you can find here: https://github.com/revol-xut/lf-alarm-clock
 
* This file contains the networking implementation it is really just an
* simple socket application which parses simple http headers and respondes
* in text/plain
*
* @author Tassilo Tanneberer <tassilo.tanneberger@tu-dresden.de>
*/

target Cpp{
    cmake-include: "AlarmClock.cmake",
    keepalive: true
};

// there needs to be a better solution to import those files
public preamble {=
    #include "../../../src/shared_header.hpp"
    #include "../../../src/crow_all.h"
=}

reactor Network {
    // physical event which is triggered by receiving a request
    physical action new_event: {= Event =};

    // variables for the receive thread
    state thread: {= std::thread =}; // receive thread
    state events: {= std::vector<Event> =}; // copy

    input updated_events: {= std::vector<Event> =};
    output event: {= Event =}; // event which will be added to the clock

    // this reaction transforms a physical action into a logical reaction
    reaction (new_event) -> event {=
        event.set(new_event.get());
    =}

    // main starts receive thread
    reaction (startup) -> new_event {=
        thread = std::thread([&] {
            crow::SimpleApp app;

            // returns json of all the upcoming events
            CROW_ROUTE(app, "/list") ([&]{
                // function converts unix timestamp to human readable datetime string
                auto unix_to_human_readable = [](unsigned int time_stamp){
                    using Clock = std::chrono::high_resolution_clock;
                    using TimePoint = std::chrono::time_point<Clock>;
                    const Clock::duration duration_time_stamp = std::chrono::seconds(time_stamp);
                    const TimePoint chrono_time_point(duration_time_stamp);
                    std::time_t end_time = std::chrono::system_clock::to_time_t(chrono_time_point);
                    std::string return_string(std::ctime(&end_time));
                    return return_string.substr(0, return_string.size() - 2);
                };

                crow::json::wvalue response;
                for (const Event& event : events ){
                    crow::json::wvalue json_event;
                    json_event["date"] = std::move(unix_to_human_readable(event.time_stamp_));
                    json_event["message"] = event.message_;

                    response[std::to_string(event.time_stamp_)] = std::move(json_event);
                };
                return crow::response(response);
            });

            // adds new event by unix time stamp
            CROW_ROUTE(app, "/add_event_timestamp").methods("POST"_method)
            ([&new_event](const crow::request& req){
                auto json_body = crow::json::load(req.body);
                if (!json_body) {
                    return crow::response(400);
                }

                // maybe add extra input validation
                Event serialized_event {
                    json_body["message"].s(),
                    static_cast<unsigned int>(json_body["time_stamp"].u())
                };

                // triggers physical action
                new_event.schedule(serialized_event, 0ms);
                crow::json::wvalue response;
                response["success"] = true;
                return crow::response(response);
            });

            // adds new event by relativ times 
            CROW_ROUTE(app, "/add_event_relative").methods("POST"_method)
            ([&new_event](const crow::request& req){
                auto relativ_time = 0l;
                auto json_body = crow::json::load(req.body);
                if (!json_body) {
                    return crow::response(400);
                }

                // calculates relative time in seconds
                if(json_body.has("days")){
                    relativ_time += 24 * 60 * 60 * json_body["days"].u();
                }
                if(json_body.has("hours")){
                    relativ_time += 60 * 60 * json_body["hours"].u();
                }
                if(json_body.has("minutes")){
                    relativ_time += 60 * json_body["minutes"].u();
                }
                if(json_body.has("seconds")){
                    relativ_time += json_body["seconds"].u();
                }

                const auto now = std::chrono::system_clock::now();
                auto current_time = std::chrono::duration_cast<std::chrono::seconds>(now.time_since_epoch()).count();

                Event serialized_event {
                    json_body["message"].s(),
                    current_time + relativ_time
                };

                // triggers physical action
                new_event.schedule(serialized_event, 0ms);
                crow::json::wvalue response;
                response["success"] = true;
                return crow::response(response);
            });

            // will set the timer in the text 24 hours
            CROW_ROUTE(app, "/add_event_time").methods("POST"_method)
            ([&new_event](const crow::request& req){
                // just % doesn't work because it is the remainder operator 
                // and does not behave like modulo for negative numbers
                auto mod = [](int a, int b) {
                    int r = a % b;
                    return r < 0 ? r + b : r;
                };

                auto relativ_time = 0l;
                auto json_body = crow::json::load(req.body);
                if (!json_body) {
                    return crow::response(400);
                }

                // use std::chrono::hh_mm_ss when C++20 is available
                time_t time_struct = time(NULL);
                struct tm *formatted_time = localtime(&time_struct);

                // calculating time differences and turning them into seconds for the time_stamp
                if(json_body.has("hour")){
                    relativ_time += 60 * 60 * mod(json_body["hour"].i() - formatted_time->tm_hour - 1, 24);
                }
                if(json_body.has("minute")){
                    relativ_time += 60 * mod(json_body["minute"].i() - formatted_time->tm_min - 1, 60);
                }
                if(json_body.has("second")){
                    relativ_time += mod(json_body["second"].u() - formatted_time->tm_sec - 1, 60);
                }

                Event serialized_event {
                    json_body["message"].s(),
                    relativ_time + time_struct
                };

                // triggers physical action
                new_event.schedule(serialized_event, 0ms);
                crow::json::wvalue response;
                response["success"] = true;
                return crow::response(response);
            });

            // request stopping playing music
            // just used pidof to kill the process
            CROW_ROUTE(app, "/stop") ([]{
                int status = system("kill $(pidof mpg321)");
                crow::json::wvalue response;
                response["success"] = status;
                return crow::response(response);
            });

            // start the http server
            app.port(kPort).multithreaded().run();
        });
    =}
    reaction (updated_events) {=
        events  = std::move(*updated_events.get());
    =}

    reaction ( shutdown ) {=
        thread.join();
    =}
}
