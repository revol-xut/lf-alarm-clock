/*
* This is a minimal example of an alarmclock implemeted using the 
* features lingua franca supplies.
* 
* This is just an extract and simplification from the main project
* which you can find here: https://github.com/revol-xut/lf-alarm-clock
* 
* This file contains the networking implementation it is really just an
* simple socket application which parses simple http headers and respondes
* in text/plain
*
* @author Tassilo Tanneberer <tassilo.tanneberger@tu-dresden.de>
*/

target Cpp{
    cmake-include: "AlarmClock.cmake",
    keepalive: true
};

public preamble {=
    #include "../../../src/shared_header.hpp"
=}


reactor Network {
    // physical event which is triggered by receiving a request
    physical action new_event: {= Event =};

    // variables for the receive thread
    state running: bool(true);
    state thread: {= std::thread =}; // receive thread
    state events: {= std::string =}; // copy

    input terminate: void;
    input updated_events: {= std::string =};

    output event: {= Event =}; // event which will be added to the clock

    // method which parsed the http header
    method response(raw_data: {= std::array<char, 4096>& =}): {= ParsedHeader =} {=
        const std::string kContentLenght = "Content-Length";
        std::string data(raw_data.data(), 4096);
        std::string header, str_iterator, body;
        std::size_t current_position = 0;
        std::size_t content_length = 0;
        ParsedHeader serialized_header;


        // start parsing the http header
        auto index_method = data.find(" ");
        serialized_header.method_ = data.substr(0, index_method);

        auto index_endpoint = data.find(" ");
        serialized_header.endpoint_ = data.substr(index_method + 1, index_method + index_endpoint - 3);
        serialized_header.endpoint_.erase(std::remove(
                serialized_header.endpoint_.begin(), 
                serialized_header.endpoint_.end(), ' '),
                serialized_header.endpoint_.end());

        // this jumps to the beginning of the body line by line
        std::istringstream iss(data);
        // iterates over the lines in the http header
        for (std::string line; std::getline(iss, line); ){
            current_position += line.size();
            if(line.empty()) {
                break;
            }else if( line.substr(0, kContentLenght.size()) == kContentLenght ){
                auto pos = line.find(" ");
                content_length = std::stoi(line.substr(pos + 1, line.size()));
                current_position += 8;
                break;
            }
        }

        // concatenates the body together2b7cecb842935c84a3a3264769ee5ece48c8ea79
        serialized_header.body_ = data.substr(current_position, current_position + content_length);
        return serialized_header;
    =}

    // this reaction transforms a physical action into a logical reaction
    reaction (new_event) -> event {=
        event.set(new_event.get());
    =}

    // main starts receive thread
    reaction (startup) -> new_event {=
        std::cout << "Starting Alarmclock Reactor!\n" << std::endl;
        constexpr const char* kResponseHeader = "HTTP/1.0 200 OK\nContent-Type: text/plain\n\n";

        thread = std::thread([&]{
            // initializing network objects from beast boost
            boost::asio::ip::tcp::endpoint ep(boost::asio::ip::address_v4::any(), kPort);
            boost::asio::io_service ios;
            boost::asio::ip::tcp::acceptor acceptor(ios, ep.protocol());

            // binds socket to address
            acceptor.bind(ep);
            acceptor.listen(kBackLog);
            boost::asio::ip::tcp::socket sock(ios);
 
            // request and response buffer
            std::array<char, 4096> data;
            std::string body_res;
            Event serialized_event {};

            std::cout << "Start receiving thread\n" << std::endl;
            while (running){
                // accepts new connection
                acceptor.accept(sock); 
                // reads data into buffer
                sock.read_some(boost::asio::buffer(data));
                auto header = response(data);

                std::cout << header.method_ << header.endpoint_ << header.body_ << std::endl;

                // handleing the endpoints
                if (header.method_ == "POST" and header.endpoint_ == "/list") {
                    body_res = events;
                } else if( header.method_ == "POST" and header.endpoint_ == "/stop") {
                    auto mpc_exit_code = system("mpc next");
                    body_res = "STOPING WITH " + std::to_string(mpc_exit_code);
                } else if( header.method_ == "POST" and header.endpoint_ == "/add") {
                    body_res = "ADDING";

                    std::size_t colon_pos = header.body_.find(";");
                    serialized_event.message_ = header.body_.substr(0, colon_pos);
                    std::string time_stamp = header.body_.substr(colon_pos + 1, header.body_.size() - 2);
                    std::cout  << time_stamp << std::endl;
                    serialized_event.time_stamp_ = static_cast<unsigned int>(std::stoi(time_stamp));

                    new_event.schedule(serialized_event, 0ms);
                }else {
                    body_res = "NO VALID ENDPOINT";
                }
                std::string composed_respone = std::string(kResponseHeader) + body_res;
                sock.write_some(boost::asio::buffer(composed_respone));
                sock.close();
            }
        });
    =}
    reaction (updated_events) {=
        events  = *updated_events.get();
        std::cout << "got new events:" << events << std::endl;
    =}


    reaction ( shutdown ) {=
        thread.join();
    =}

    reaction (terminate) {=
        running = false;
    =}

}
