/*
* This is a minimal example of an alarmclock implemeted using the 
* features lingua franca supplies.
* 
* This is just an extract and simplification from the main project
* which you can find here: https://github.com/revol-xut/lf-alarm-clock
* 
* This file contains the networking implementation it is really just an
* simple socket application which parses simple http headers and respondes
* in text/plain
*
* @author Tassilo Tanneberer <tassilo.tanneberger@tu-dresden.de>
*/

target Cpp{
    cmake-include: "AlarmClock.cmake",
    keepalive: true
};

import Clock from "./Clock.lf";

public preamble {=
    #include <boost/asio.hpp>

    // very simple struct to handle http request
    struct ParsedHeader {
        std::string method_;
        std::string endpoint_;
        std::string body_;
    };

    constexpr short kBackLog = 30;
    constexpr unsigned short kPort = 6666;
=}


main reactor Networking {
    // imported clock reactor which handles persistent storage and scheduling of events
    clock = new Clock();

    // physical event which is triggered by receiving a request
    physical action new_event: {= Event =};

    // variables for the receive thread
    state running: bool(true);
    state thread: {= std::thread =}

    input terminate: void;
    output event: {= std::string =};

    // method which parsed the http header
    method response(raw_data: {= std::array<char, 4096>& =}): {= ParsedHeader =} {=
        const std::string kContentLenght = "Content-Length";
        std::string data(raw_data.data(), 4096);
        std::string header, str_iterator, body;
        std::size_t current_position = 0;
        std::size_t content_length = 0;

        // start parsing the http header
        auto index_method = data.find(" ");
        std::string http_method = data.substr(0, index_method);
        auto index_endpoint = data.find(" ");
        std::string http_endpoint = data.substr(index_method + 1, index_method + index_endpoint - 3);

        // this jumps to the beginning of the body line by line
        std::istringstream iss(data);
        
        // iterates over the lines in the http header
        for (std::string line; std::getline(iss, line); ){
            current_position += line.size();
            if(line.empty()) {
                break;
            }else if( line.substr(0, kContentLenght.size()) == kContentLenght ){
                auto pos = line.find(" ");
                content_length = std::stoi(line.substr(pos + 1, line.size()));
                current_position += 8;
                break;
            }
        }

        // concatenates the body together
        body = data.substr(current_position, current_position + content_length);
        return ParsedHeader {
            http_method,
            http_endpoint,
            body
        };
    =}

    // this reaction transforms a physical action into a logical reaction
    reaction (new_event) -> clock.event {=
        clock.event.set(new_event.get());
    =}

    // main starts receive thread
    reaction (startup) -> new_event {=
        std::cout << "Starting Alarmclock Reactor!\n" << std::endl;
        constexpr const char* kResponseHeader = "HTTP/1.0 200 OK\nContent-Type: text/plain\n\n";

        thread = std::thread([&]{
            // initializing network objects from beast boost
            boost::asio::ip::tcp::endpoint ep(boost::asio::ip::address_v4::any(), kPort);
            boost::asio::io_service ios;
            boost::asio::ip::tcp::acceptor acceptor(ios, ep.protocol());

            // binds socket to address
            acceptor.bind(ep);
            acceptor.listen(kBackLog);
            boost::asio::ip::tcp::socket sock(ios);
 
            // request and response buffer
            std::array<char, 4096> data;
            std::string body_res;
            Event serialized_event {};

            std::cout << "Start receiving thread\n" << std::endl;
            while (running){
                // accepts new connection
                acceptor.accept(sock); 
                // reads data into buffer
                sock.read_some(boost::asio::buffer(data));
                auto header = response(data);

                std::cout << header.method_ << header.endpoint_ << header.body_ << std::endl;

                // handleing the endpoints
                if (header.method_ == "POST" and header.endpoint_ == "/list") {
                    body_res = clock->print_events();
                } else if( header.method_ == "POST" and header.endpoint_ == "/stop") {
                    auto mpc_exit_code = system("mpc next");
                    body_res = "STOPING WITH " + std::to_string(mpc_exit_code);
                } else if( header.method_ == "POST" and header.endpoint_ == "/add") {
                    body_res = "ADDING";

                    std::size_t colon_pos = header.body_.find(";");
                    serialized_event.message_ = header.body_.substr(0, colon_pos);
                    serialized_event.time_stamp_ = static_cast<unsigned int>(
                        std::stoi(header.body_.substr(colon_pos + 1, header.body_.size() - 2)));

                    new_event.schedule(serialized_event, 0ms);
                }else {
                    body_res = "NO VALID ENDPOINT";
                }
                std::string composed_respone = std::string(kResponseHeader) + body_res;
                sock.write_some(boost::asio::buffer(composed_respone));
                sock.close();
            }
        });
    =}

    reaction ( shutdown ) {=
        thread.join();
    =}

    reaction (terminate) {=
        running = false;
    =}

}
