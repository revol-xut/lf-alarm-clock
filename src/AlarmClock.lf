

target Cpp{
    cmake-include: "AlarmClock.cmake",
    keepalive: true
};


public preamble {=
    #include <boost/asio.hpp>
    #include <iostream>
    #include <string>
    #include <thread>
    #include <fstream>
    #include <filesystem>

    struct Event {
        std::string message_;
        unsigned int time_stamp_;
    };
    
    struct ParsedHeader {
        std::string method_;
        std::string endpoint_;
        std::string body_;
    };

    auto time_over(const Event& event) noexcept -> bool {
        auto unix_time = (event.time_stamp_);
        const auto p1 = std::chrono::system_clock::now();
        auto current_time = std::chrono::duration_cast<std::chrono::seconds>(p1.time_since_epoch()).count();
        return current_time > unix_time;
    }

    constexpr short kBackLog = 30;
    constexpr unsigned short kPort = 6666;
    constexpr const char* kMusicDir = "/home/revol-xut/music/AlarmClock/";
    constexpr const char* kFile = "./alarm_clock_events.csv";
=}


reactor Trigger {
    input stop: void;
    logical action event: {=std::string=}

    reaction(event) {=
        auto select_random_file = []{
            std::vector<std::string> files;
            for (const auto& file : std::filesystem::directory_iterator(kMusicDir)) {
                files.push_back(file.path().filename());
            }

            return files[rand() % files.size()];
        };

        if(event.is_present()){
            std::cout << "Triggering Event: " << *(event.get().get()) << std::endl;
            std::string command = "mpc add AlarmClock/" + select_random_file();
            if( system(command.c_str()) != 0 ){
                std::runtime_error("mpc finished with non zero return value");
            }
        }
    =}
}

reactor Clock {
    trigger = new Trigger();
    // this event will be scheduled and added to persistent storage
    input event: Event;
    // list of indices which can be removed from persistent storage
    input removed: std::vector<std::size_t>;
    // timer which triggers clear and save
    timer maintance(10 sec, 30 sec);

    // persistant storage
    state events: std::vector<Event>();
    output events_out: std::vector<Event>;

    // reaction that appends elements
    reaction (event) -> trigger.event {=
        if (event.is_present() ){
            auto extracted = event.get().get();
            std::cout << "Adding event to event pipeline\n" << std::endl;
            events.push_back(*extracted);
            
            const auto t = std::chrono::system_clock::now();
            std::chrono::seconds desired_time = std::chrono::seconds(extracted->time_stamp_);
            std::chrono::seconds current_time = std::chrono::duration_cast<std::chrono::seconds>(t.time_since_epoch());
            std::chrono::seconds delta_t = desired_time - current_time;
            trigger.event.schedule(extracted->message_, delta_t);
        }
    =}

    // checking periodically if elements need to be triggered
    reaction (maintance) -> events_out {=
        events_out.set(events);
    =}

    // initiation ... reading file to create state 
    reaction (startup) {=
        if (not std::filesystem::exists(kFile)){
            std::ofstream{kFile};
        }

        std::ifstream file;
        file.open(kFile);

        std::string line;
        if(not file.is_open()) {
            throw std::runtime_error("Cannot open event file!");
        }

        while (file) {
            std::getline(file, line);
            if (line.empty()) {
                break;
            }

            Event serialized_event {};
            std::size_t colon_pos = line.find(";");
            serialized_event.message_ = line.substr(0, colon_pos);
            serialized_event.time_stamp_ = static_cast<unsigned int>(
                std::stoi(line.substr(colon_pos + 1, line.size() - 2))
            );

            if(not time_over(serialized_event)){
                trigger.event.set(serialized_event);
                events.push_back(serialized_event);
            }
        }

        file.close();
    =}

    // state needs to be saved to file
    reaction (shutdown, maintance) {=
        remove_events();
        save();
    =}

    method remove_events() {=
        // list of element which can be removed in the next iteration
        std::vector<std::size_t> removed_indices;
        std::size_t index = 0;
        for(const Event& event: events) {
            if (time_over(event)){
                removed_indices.push_back(index);
            }
            index++;
        }

        std::size_t removed_counter = 0;
        for (std::size_t i : removed_indices) {
            events.erase(events.begin() + i - removed_counter);
            removed_counter++;
        }
    =}
    
    method save() {=
        std::ofstream file(kFile, std::ios::trunc);

        for (const Event& e : events ) {
            file << e.message_ + ";" + std::to_string(e.time_stamp_) + "\n";
        }

        file.close();
    =}

    const method print_events(): {=std::string=} {=
        std::string return_value;

        auto unix_to_human_readable = [](unsigned int time_stamp){
            using Clock = std::chrono::high_resolution_clock;
            using TimePoint = std::chrono::time_point<Clock>;
            
            const Clock::duration duration_time_stamp = std::chrono::seconds(time_stamp);
            const TimePoint chrono_time_point(duration_time_stamp);
            std::time_t end_time = std::chrono::system_clock::to_time_t(chrono_time_point);
            return std::ctime(&end_time);
        };
        
        for (const Event& event: events) {
            return_value += event.message_ + ";" + unix_to_human_readable(event.time_stamp_) + "\n";
        };

        return return_value;
    =}

}


main reactor AlarmClock {
    clock = new Clock();

    physical action new_event: {= Event =};
    state running: bool(true);
    state thread: {= std::thread =}

    input terminate: void;
    output event: {= std::string =};

    method response(raw_data: {= std::array<char, 4096>& =}): {= ParsedHeader =} {=
        const std::string kContentLenght = "Content-Length";
        std::string data(raw_data.data(), 4096);
        std::string header, str_iterator, body;
        std::size_t current_position = 0;
        std::size_t content_length = 0;

        // start parsing the http header
        auto index_method = data.find(" ");
        std::string http_method = data.substr(0, index_method);
        auto index_endpoint = data.find(" ");
        std::string http_endpoint = data.substr(index_method + 1, index_method + index_endpoint - 3);

        // this jumps to the beginning of the body line by line
        std::istringstream iss(data);

        for (std::string line; std::getline(iss, line); ){
            current_position += line.size();
            if(line.empty()) {
                break;
            }else if( line.substr(0, kContentLenght.size()) == kContentLenght ){
                auto pos = line.find(" ");
                content_length = std::stoi(line.substr(pos + 1, line.size()));
                current_position += 8;
                break;
            }
        }

        // concatenates the body together
        body = data.substr(current_position, current_position + content_length);
        return ParsedHeader {
            http_method,
            http_endpoint,
            body
        };
    =}

    reaction (new_event) -> clock.event {=
        clock.event.set(new_event.get());
    =}


    reaction (startup) -> new_event {=
        std::cout << "Starting Alarmclock Reactor!\n" << std::endl;
        constexpr const char* kResponseHeader = "HTTP/1.0 200 OK\nContent-Type: text/plain\n\n";

        thread = std::thread([&]{
            // initializing network objects from beast boost
            boost::asio::ip::tcp::endpoint ep(boost::asio::ip::address_v4::any(), kPort);
            boost::asio::io_service ios;
            boost::asio::ip::tcp::acceptor acceptor(ios, ep.protocol());
            acceptor.bind(ep);
            acceptor.listen(kBackLog);
            boost::asio::ip::tcp::socket sock(ios);
            
            // request and response buffer
            std::array<char, 4096> data;
            std::string body_res;
            Event serialized_event {};

            std::cout << "Start receiving thread\n" << std::endl;
            while (running){
                acceptor.accept(sock); 
                sock.read_some(boost::asio::buffer(data));
                auto header = response(data);

                // handleing the endpoints
                if (header.method_ == "POST" and header.endpoint_ == "/list") {
                    //body_res = clock->print_events();
                } else if( header.method_ == "POST" and header.endpoint_ == "/stop") {
                    auto mpc_exit_code = system("mpc next");
                    body_res = "STOPING WITH " + std::to_string(mpc_exit_code);
                } else if( header.method_ == "POST" and header.endpoint_ == "/add") {
                    body_res = "ADDING";

                    std::size_t colon_pos = header.body_.find(";");
                    serialized_event.message_ = header.body_.substr(0, colon_pos);
                    serialized_event.time_stamp_ = static_cast<unsigned int>(
                        std::stoi(header.body_.substr(colon_pos + 1, header.body_.size() - 2)));

                    new_event.schedule(serialized_event, 0ms);
                }else {
                    body_res = "NO VALID ENDPOINT";
                }
                std::string composed_respone = std::string(kResponseHeader) + body_res;
                sock.write_some(boost::asio::buffer(composed_respone));
                sock.close();
            }
        });
    =}

    reaction ( shutdown ) {=
        thread.join();
    =}

    reaction (terminate) {=
        running = false;
    =}

}
